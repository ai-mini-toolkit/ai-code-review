---
stepsCompleted: [1, 2, 3, 4, 5, 6, 7, 14]
inputDocuments:
  - _bmad-output/planning-artifacts/prd.md
  - _bmad-output/implementation-artifacts/product-brief.md
  - README.md
project_name: ai-code-review
user_name: ethan
date: 2026-02-05
lastStep: 14
workflowComplete: true
completedAt: 2026-02-05
---

# UX Design Specification ai-code-review

**Author:** ethan
**Date:** 2026-02-05

---

<!-- UX design content will be appended sequentially through collaborative workflow steps -->

## Executive Summary

### Project Vision

AI Code Review 是一个智能代码审查系统，旨在通过自动化和 AI 技术提升代码质量和开发效率。系统通过 Webhook 自动触发，对代码变更进行多维度智能审查，包括代码质量、安全问题、性能分析、代码风格、Bug 预测和调用链路分析。核心目标是统一开发规范、清洗调用链路、提高交付质量，最终实现代码审查覆盖率提升 50%、审查效率提升 3 倍、线上 Bug 率降低 30%。

### Target Users

**主要用户群体：**

1. **个人开发者**
   - 管理小型项目，希望自动检查代码质量
   - 需要简单易用的配置和清晰的问题反馈
   - 技术熟练，能理解代码审查术语

2. **开发团队成员**
   - 日常提交代码并查看审查结果
   - 需要快速定位问题、获取修复建议
   - 关注代码规范统一性和团队协作

3. **项目管理者/团队 Leader**
   - 配置审查规则和阈值策略
   - 管理多个项目的代码质量标准
   - 需要全局视角和趋势分析能力

4. **企业 DevOps 工程师**
   - 集成系统到企业 CI/CD 流程
   - 配置 Webhook 和通知渠道
   - 关注系统稳定性和扩展性

### Key Design Challenges

1. **信息密度管理**
   - 审查报告包含大量技术细节：代码片段、问题列表、调用链路、评分详情
   - 需要清晰的信息层次结构，避免信息过载
   - 必须支持多层级的信息展示和按需展开机制
   - 需要高效的筛选和搜索功能（按严重级别、类别、文件路径）

2. **复杂配置简化**
   - 系统配置项众多：AI 模型配置、Webhook 设置、阈值策略、通知规则、路径过滤、审查模板
   - 需要将技术复杂度转化为用户友好的界面
   - 需要提供配置向导和智能默认值
   - 必须支持配置模板和快速复制功能

3. **调用链路可视化**
   - 代码调用关系复杂，需要转化为直观的可视化图表
   - 必须支持交互探索（缩放、拖拽、点击高亮）
   - 需要清晰标识循环依赖和过深调用链等问题
   - 支持多种导出格式（PNG、SVG、Mermaid、PlantUML）

4. **多项目管理体验**
   - 用户可能管理多个项目，每个项目配置不同
   - 需要清晰的项目切换和批量操作能力
   - 配置继承和模板复用机制

### Design Opportunities

1. **智能化配置引导**
   - 利用 AI 能力提供智能配置推荐（根据项目类型、编程语言推荐审查规则）
   - 智能识别常见配置错误并给出修正建议
   - 提供交互式配置向导，降低首次使用门槛

2. **高效问题定位**
   - 通过优秀的信息架构快速定位关键问题
   - Error 级别问题优先展示并高亮
   - 提供"一键跳转到代码位置"功能
   - 智能关联相似问题，批量处理

3. **可视化体验创新**
   - 调用链路图可以成为产品差异化亮点
   - 提供交互式探索体验（点击节点查看详情、高亮依赖路径）
   - 支持不同视图模式（层次树状图、力导向图、矩阵图）
   - 实时渲染，性能优化

4. **协作与通知优化**
   - 审查结果直接集成到开发工作流（Git PR 评论）
   - 个性化通知偏好设置
   - 支持团队成员间的审查结果讨论和标注

## Core User Experience

### Defining Experience

AI Code Review 的核心用户体验围绕**"快速理解代码问题并知道如何修复"**展开。当开发者提交代码后，系统自动触发审查，生成详细的审查报告。用户的首要任务是在最短时间内理解所有问题的严重性、位置和修复方法。

**核心用户行为流程：**

1. **自动触发** - 开发者 Push 代码或创建 PR，无需手动操作
2. **接收通知** - 通过邮件或 Git 评论收到审查完成通知
3. **查看报告** - 打开 Web 界面，浏览审查结果
4. **定位问题** - 快速筛选和定位 Error 级别的关键问题
5. **理解问题** - 查看代码片段、问题描述和修复建议
6. **采取行动** - 修复代码或调整配置规则

**次要用户行为：**

- 项目管理者配置审查规则和阈值
- 团队成员探索调用链路图理解代码架构
- DevOps 工程师配置 Webhook 和集成

### Platform Strategy

**主平台：Web 应用（桌面浏览器优先）**

- **设备支持**：桌面（主要）、平板（次要）、移动（查看报告）
- **交互模式**：鼠标/键盘为主，支持触摸屏
- **浏览器兼容**：Chrome、Firefox、Safari、Edge（现代浏览器）
- **屏幕尺寸**：优化 1920x1080 及以上，最小支持 1366x768
- **技术栈约束**：Vue 3 + Vue-Vben-Admin + Element Plus

**平台关键能力需求：**

- **复杂数据可视化**：调用链路图需要 Canvas/SVG 渲染，支持缩放、拖拽、交互
- **代码展示**：语法高亮、行号、diff 对比
- **实时更新**：任务状态变化时实时刷新（WebSocket 或轮询）
- **多窗口协作**：支持多标签页同时查看不同项目或报告
- **响应式布局**：适配不同屏幕尺寸，关键功能在所有设备上可用

**不需要的功能：**

- 离线功能（依赖后端 AI 审查）
- 原生移动应用（Web 响应式足够）
- 桌面应用打包

### Effortless Interactions

**完全自动化的操作（零用户操作）：**

1. **审查触发** - Webhook 自动触发，无需手动启动
2. **问题分类** - AI 自动将问题分类到安全/性能/质量等维度
3. **严重级别判定** - 自动判定 Error/Warning/Info 级别
4. **通知发送** - 审查完成后自动发送邮件和 Git 评论
5. **状态回写** - PR 状态自动更新为通过/阻止

**一键完成的操作：**

1. **问题筛选** - 点击标签即可筛选特定类型或级别的问题
2. **代码跳转** - 点击问题卡片直接展开代码片段和上下文
3. **配置复制** - 从现有项目一键复制配置到新项目
4. **报告导出** - 一键导出调用链路图（PNG/SVG/Mermaid）
5. **批量标记** - 选择多个问题批量标记为"已处理"或"忽略"

**智能默认值：**

1. **首次配置** - 根据仓库语言（Java/Python/JS）自动推荐审查模板
2. **阈值建议** - 根据项目类型建议合理的阈值（Error=0, Score≥60）
3. **路径过滤** - 自动识别 test 目录并建议排除

**减少的步骤：**

- 传统流程：手动触发 → 等待 → 下载报告 → 查找问题 → 理解问题
- 优化流程：自动触发 → 收到通知 → 点击查看 → 问题已分类并高亮

### Critical Success Moments

**"这个更好"的关键时刻：**

1. **首次审查完成（T+30秒）**
   - 提交代码后 30 秒内收到详细审查报告
   - 看到 AI 发现了 15+ 个问题（包括潜在安全漏洞）
   - 意识到："这比人工审查更快更全面"

2. **调用链路可视化（T+2分钟）**
   - 点击"调用链路"标签，看到交互式依赖图
   - 发现循环依赖被红色高亮标出
   - 意识到："复杂的架构问题一目了然"

3. **问题成功阻止合并（T+5分钟）**
   - PR 因 Error 级别问题被自动阻止
   - Git 平台显示清晰的失败原因和修复建议
   - 意识到："这能真正保障代码质量"

4. **快速定位修复（T+10分钟）**
   - 使用筛选功能快速找到所有 SQL 注入风险
   - 点击问题查看具体代码和修复建议
   - 5 分钟内修复所有问题并重新提交
   - 意识到："修复效率大幅提升"

5. **配置生效验证（T+1小时）**
   - 调整阈值配置（Error=0 → Warning=5）
   - 下次审查立即应用新规则
   - 意识到："配置灵活且即时生效"

**成败关键流程：**

- **首次项目配置** - 必须在 5 分钟内完成基础配置
- **审查报告首屏** - 必须在 3 秒内看到关键问题（Error 级别）
- **问题理解** - 必须在 10 秒内理解问题和修复方向
- **调用链路加载** - 必须在 5 秒内渲染完成（即使复杂项目）

### Experience Principles

**指导所有 UX 决策的核心原则：**

1. **信息透明，层次清晰**
   - 关键信息（Error 级别问题）永远在首屏
   - 细节内容按需展开，避免信息过载
   - 使用视觉层次（颜色、大小、位置）引导注意力
   - 提供多种视图模式（列表/卡片/表格）满足不同场景

2. **自动化优先，配置简化**
   - 能自动完成的操作绝不要求用户手动操作
   - 提供智能默认值和推荐配置
   - 复杂配置提供向导式引导
   - 支持配置模板和一键复制

3. **快速定位，高效操作**
   - 从问题发现到采取行动路径最短（≤3 次点击）
   - 提供强大的筛选、搜索和排序功能
   - 支持键盘快捷键（高级用户）
   - 批量操作减少重复点击

4. **可视化驱动理解**
   - 复杂概念通过图表直观呈现（调用链路、趋势分析）
   - 交互式探索（缩放、高亮、钻取）
   - 代码片段语法高亮和 diff 对比
   - 使用图标和颜色编码快速识别

5. **渐进式披露**
   - 新手看到简化视图和操作引导
   - 专家用户可以深入细节和高级配置
   - 提供"快速开始"和"高级配置"两种路径
   - 根据用户行为动态调整界面复杂度

## Desired Emotional Response

### Primary Emotional Goals

AI Code Review 旨在让用户在整个代码审查过程中感受到**掌控感、高效性和信任**。这三个核心情感目标共同塑造产品的情感基调。

**1. 掌控感与自信（Empowered & Confident）**

用户应该感觉代码质量完全掌握在自己手中。当看到详细的审查报告时，能够清晰地知道所有问题的位置、严重性和修复方向，而不是感到不知所措。修复问题时充满信心，因为有 AI 提供的清晰指引和具体建议。

**2. 高效与专业（Efficient & Professional）**

使用产品时应该感受到工作流程的高效性和专业性。体验到"30 秒完成原本需要 30 分钟人工审查"的效率提升，感受到系统化、标准化带来的专业感。每个操作都应该让用户感觉"这节省了我的时间"。

**3. 安心与信任（Secure & Trust）**

用户应该对代码质量感到安心，相信有 AI 守护，关键问题不会被遗漏。对系统的审查结果和判定标准建立信任，相信 Error 级别的问题会被可靠地阻止合并。这种信任感是用户持续使用产品的基础。

### Emotional Journey Mapping

**阶段 1：首次发现（Discovery）**
- **情感状态**：好奇、期待、略带谨慎
- **用户心声**："这个工具看起来很强大，但配置会很复杂吗？"
- **UX 支持**：清晰的价值主张、简单的首次配置向导、智能默认值

**阶段 2：首次配置（Onboarding）**
- **情感状态**：专注、略有紧张、期待成功
- **用户心声**："我希望快速配置好，不要遇到复杂的技术问题。"
- **UX 支持**：分步骤引导、智能推荐配置、即时验证反馈

**阶段 3：核心体验（Core Experience）**
- **情感状态**：专注、掌控、高效
- **用户心声**："我能快速找到所有问题，知道该做什么。"
- **UX 支持**：清晰的信息层次、快速筛选、一键操作、详细的修复建议

**阶段 4：任务完成（Completion）**
- **情感状态**：成就感、满意、信赖
- **用户心声**："所有问题都修复了，代码质量明显提升了！"
- **UX 支持**：清晰的完成反馈、改进对比展示、正向强化

**阶段 5：遇到问题（Error Handling）**
- **情感状态**：理解、支持（非挫败）
- **用户心声**："我知道为什么失败，也知道如何解决。"
- **UX 支持**：清晰的错误说明、建议的解决方案、帮助文档链接

**阶段 6：再次使用（Return Visit）**
- **情感状态**：熟悉、信赖、习惯
- **用户心声**："这个工具已经成为我工作流程不可或缺的一部分。"
- **UX 支持**：一致的交互模式、记住用户偏好、持续的价值传递

### Micro-Emotions

**必须建立的关键微情感：**

1. **信心 > 困惑**
   - 清晰的问题分级（Error/Warning/Info）
   - 详细的修复建议和代码示例
   - 解释性的问题描述，避免模糊术语

2. **信任 > 怀疑**
   - 准确的问题识别和合理的判定
   - 解释 AI 判断依据和审查标准
   - 允许用户自定义规则和反馈错误

3. **成就 > 挫败**
   - 清晰的进度和完成反馈
   - 问题修复后的正向强化（评分提升）
   - 简化复杂配置，提供智能默认值

4. **专注 > 分心**
   - 信息层次清晰，关键信息突出
   - 减少不必要的通知和干扰
   - 支持用户自定义信息密度

5. **满意 > 失望**
   - 快速响应（3 秒内显示关键信息）
   - 准确结果和有用的建议
   - 管理预期，提供反馈机制

### Design Implications

**情感目标驱动的 UX 设计决策：**

**1. 掌控感 → 信息透明与可配置性**
- 所有审查规则清晰可见且可配置
- 展示审查过程和判定依据
- 提供"为什么这是问题"的详细解释
- 允许用户自定义规则和阈值

**2. 高效感 → 快速操作与自动化**
- 首屏 3 秒内显示关键问题（Error 级别）
- 一键筛选、批量操作、快捷键支持
- 自动触发审查，无需手动操作
- 智能推荐和自动填充配置

**3. 信任感 → 可靠性与透明度**
- 显示 AI 模型信息和审查维度
- 提供问题严重性的明确标准
- 展示审查历史和准确率趋势
- 允许用户标记误报并反馈

**4. 成就感 → 正向反馈与可视化**
- 问题修复后显示"改进对比"
- 展示代码质量评分变化趋势
- 突出展示"0 Error"的成功状态
- 提供审查历史和改进统计

**5. 专业感 → 视觉设计与一致性**
- 简洁专业的界面设计（遵循 Vue-Vben-Admin 规范）
- 技术感的调用链路可视化
- 统一的视觉语言和交互模式
- 代码语法高亮和专业的排版

### Emotional Design Principles

**指导情感化设计的核心原则：**

**原则 1：透明化构建信任**
- 不隐藏系统逻辑，清晰解释每个判定
- 展示审查过程和 AI 推理依据
- 提供用户反馈和自定义规则的能力
- 管理用户期望，避免过度承诺

**原则 2：简化减少焦虑**
- 复杂功能提供简单入口和高级入口两种路径
- 智能默认值减少配置负担
- 分步骤引导复杂流程
- 及时的帮助提示和文档链接

**原则 3：反馈强化成就**
- 每个重要操作提供即时反馈
- 正向强化用户的改进行为（评分提升、问题减少）
- 可视化进度和成果
- 庆祝成功时刻（0 Error 状态）

**原则 4：尊重用户时间**
- 快速响应（3 秒原则）
- 减少不必要的点击和等待
- 智能通知，避免打扰
- 支持批量操作和快捷键

**原则 5：持续传递价值**
- 每次使用都能感受到价值（发现问题、提升质量）
- 展示长期价值（审查历史、质量趋势）
- 适应用户成长（新手引导 → 专家功能）
- 持续优化和改进用户体验

## UX Pattern Analysis & Inspiration

### Inspiring Products Analysis

基于 AI Code Review 的特点（开发者工具、数据密集、可视化、配置管理），我们分析了相关领域的优秀产品及其 UX 模式。

**产品 1：GitHub（代码托管与审查）**

- **UX 优势**：清晰的信息层次、内联评论系统、状态可视化、优化的 Diff 视图
- **有效原因**：开发者可以快速扫描获取关键信息，内联评论保持上下文
- **可借鉴**：审查报告的清晰信息层次、问题与代码的内联展示、颜色编码传达严重级别

**产品 2：VS Code（开发工具）**

- **UX 优势**：问题面板设计、快速修复建议、键盘优先、渐进式披露
- **有效原因**：问题面板快速定位、快速修复降低修复门槛、键盘快捷键提升效率
- **可借鉴**：问题列表的分组和数量徽章、悬停显示详情和修复建议、键盘快捷键支持

**产品 3：Datadog / Grafana（监控可视化）**

- **UX 优势**：仪表盘设计、交互式图表、告警可视化、灵活的时间选择
- **有效原因**：复杂数据通过可视化易于理解、交互式探索支持深入分析
- **可借鉴**：调用链路可视化的交互设计、多维度数据的仪表盘布局、问题趋势图表

**产品 4：Sentry（错误追踪）**

- **UX 优势**：结构化问题详情、上下文信息收集、严重级别判定、灵活通知策略
- **有效原因**：结构化信息帮助快速理解、上下文减少调查时间
- **可借鉴**：问题详情的结构化展示、上下文信息的自动收集、通知策略的灵活配置

**产品 5：Linear（项目管理）**

- **UX 优势**：极致性能、键盘驱动、简洁视觉设计、智能搜索
- **有效原因**：快速响应让用户感觉高效、简洁设计减少视觉干扰
- **可借鉴**：性能优化（3 秒原则）、命令面板式的全局搜索、简洁专业的视觉风格

### Transferable UX Patterns

**导航模式：**

1. **侧边栏 + 主内容区布局**（GitHub, VS Code）
   - 左侧项目/文件列表导航，主区域显示详情内容
   - 适用于：项目管理、审查历史浏览

2. **标签页切换**（VS Code, Chrome DevTools）
   - 多个视图通过标签页切换（报告/链路图/配置）
   - 适用于：审查详情的多维度查看

3. **面包屑导航**（GitHub, Sentry）
   - 显示当前位置层级
   - 适用于：深层级配置或详情页

**交互模式：**

1. **问题列表 + 详情面板**（VS Code, Sentry）
   - 左侧问题列表，点击展开右侧详情，支持键盘导航
   - 适用于：审查问题列表

2. **内联展开/折叠**（GitHub PR）
   - 默认折叠代码，点击展开查看详情，避免信息过载
   - 适用于：代码片段展示

3. **悬停显示详情**（VS Code）
   - 鼠标悬停显示 tooltip 或 popover，快速查看无需离开当前页面
   - 适用于：问题的快速预览

4. **拖拽交互**（Grafana, Draw.io）
   - 可视化图表支持拖拽调整
   - 适用于：调用链路图的交互探索

**视觉模式：**

1. **颜色编码系统**（GitHub, VS Code, Datadog）
   - 红色 = Error/危险、黄色 = Warning/警告、绿色 = Success/通过、蓝色 = Info/信息
   - 适用于：问题严重级别、状态标识

2. **徽章和标签**（GitHub, Linear）
   - 数量徽章（3 Errors, 8 Warnings）、类别标签（Security, Performance）
   - 适用于：快速识别和筛选

3. **卡片式布局**（Trello, Notion）
   - 信息以卡片形式组织，清晰的边界和层次
   - 适用于：审查历史列表、配置项

4. **代码高亮**（GitHub, VS Code, GitLab）
   - 语法高亮提升可读性、Diff 高亮显示变更
   - 适用于：代码片段展示

### Anti-Patterns to Avoid

**反模式 1：信息过载的首屏**
- 问题：一次性展示所有信息，用户不知道从哪里开始
- 避免方式：优先展示关键信息（Error 级别），细节按需展开

**反模式 2：复杂的多步骤配置**
- 问题：配置流程冗长且缺乏指引，用户容易放弃
- 避免方式：提供向导式配置和智能默认值

**反模式 3：缺乏上下文的问题列表**
- 问题：只显示问题描述，不显示代码位置或影响范围
- 避免方式：问题与代码内联展示，提供充分上下文

**反模式 4：不一致的交互模式**
- 问题：不同页面使用不同的交互方式，增加学习成本
- 避免方式：建立统一的交互规范和组件库（Element Plus）

**反模式 5：性能差的可视化**
- 问题：复杂图表加载慢或交互卡顿
- 避免方式：性能优化（虚拟滚动、分页、懒加载）

**反模式 6：过度依赖颜色**
- 问题：只用颜色区分信息，色盲用户无法使用
- 避免方式：颜色 + 图标 + 文字三重编码

### Design Inspiration Strategy

**采用的模式：**

1. **侧边栏 + 主内容区布局**
   - 原因：符合开发者习惯，信息层次清晰
   - 应用于：整体应用布局

2. **问题列表 + 详情面板**
   - 原因：高效浏览和深入查看兼顾
   - 应用于：审查报告的问题展示

3. **颜色编码 + 徽章系统**
   - 原因：快速识别严重性和类别
   - 应用于：问题级别和分类标识

4. **内联展开/折叠**
   - 原因：避免信息过载，按需披露
   - 应用于：代码片段和详细信息

**改编的模式：**

1. **命令面板 → 全局搜索**
   - 改编：简化为搜索框 + 快捷筛选，不做完整命令面板
   - 原因：降低复杂度，保留核心价值

2. **拖拽交互 → 点击高亮**
   - 改编：调用链路图主要用点击和缩放，拖拽作为辅助
   - 原因：降低技术复杂度，满足主要需求

3. **键盘优先 → 键盘增强**
   - 改编：提供关键快捷键，不强制键盘驱动
   - 原因：适应不同用户习惯

**避免的模式：**

1. **多步骤向导**
   - 原因：开发者更喜欢一页完成配置
   - 替代方案：单页表单 + 分组折叠

2. **过度动画**
   - 原因：开发工具强调效率而非炫酷
   - 替代方案：简洁的过渡动画

3. **隐藏的高级功能**
   - 原因：开发者希望看到所有功能选项
   - 替代方案：默认显示常用，高级功能可见但收起

## Design System Foundation

### Design System Choice

**选定方案：Element Plus + Vue-Vben-Admin**

AI Code Review 项目采用 **Element Plus** 作为核心 UI 组件库，配合 **Vue-Vben-Admin** 管理后台框架。这是一个基于项目技术栈约束（Vue 3 + Vue-Vben-Admin + Element Plus）的自然选择，同时也是最符合项目需求的方案。

**Element Plus** 是 Element UI 的 Vue 3 版本，提供了 100+ 个企业级组件，具有专业的视觉风格和优秀的开发体验。**Vue-Vben-Admin** 则是基于 Element Plus 的管理后台框架，提供开箱即用的布局、路由、权限和状态管理解决方案。

### Rationale for Selection

**1. 技术适配性**
- 原生支持 Vue 3 Composition API 和 TypeScript
- 与项目技术栈（Vue 3 + Vue-Vben-Admin）完美匹配
- 团队学习曲线低，开发效率高

**2. 功能完整性**
- 覆盖所有基础 UI 组件需求（表格、表单、图表、对话框、通知等）
- Vue-Vben-Admin 提供完整的后台管理模板和最佳实践
- 减少从零开始的基础架构开发工作

**3. 视觉专业性**
- Element Plus 的设计风格专业、简洁、清晰
- 适合开发者工具和企业级应用的审美
- 完美契合"专业感"和"高效感"的情感设计目标

**4. 开发效率**
- 丰富的组件库显著提升开发速度
- Vue-Vben-Admin 提供现成的页面模板和示例代码
- 快速搭建原型和 MVP，缩短上市时间

**5. 可定制性**
- 支持主题定制（颜色、字体、圆角、阴影等）
- CSS 变量系统方便全局样式调整
- 组件级别的灵活配置和扩展能力

**6. 生态与维护**
- Element Plus 和 Vue-Vben-Admin 都有活跃的社区
- 持续更新和 bug 修复，长期维护有保障
- 丰富的第三方插件和工具生态

**7. 可访问性与性能**
- 内置 ARIA 支持，符合无障碍标准
- 性能优化良好，支持按需加载
- 移动端适配（响应式设计）

### Implementation Approach

**阶段 1：基础搭建（Week 1）**

1. **项目初始化**
   - 基于 Vue-Vben-Admin 脚手架初始化项目
   - 配置项目结构和目录组织
   - 设置 ESLint、Prettier 代码规范

2. **布局架构**
   - 配置主布局（侧边栏 + 顶部栏 + 主内容区）
   - 设置路由结构和导航菜单
   - 实现页面切换和面包屑导航

3. **基础配置**
   - 配置 Element Plus 全局引入或按需加载
   - 设置主题颜色和设计 tokens
   - 建立组件使用规范文档

**阶段 2：主题定制（Week 2）**

1. **颜色系统定义**
   - 主色调：#409EFF（蓝色，代表专业和信任）
   - 语义色：Error (#F56C6C)、Warning (#E6A23C)、Success (#67C23A)、Info (#909399)
   - 中性色：文本色、边框色、背景色体系

2. **组件样式定制**
   - 定制关键组件的样式（表格、表单、卡片、标签）
   - 统一问题严重级别的视觉呈现
   - 优化代码展示的排版和高亮

3. **排版规范**
   - 定义标题层级（H1-H6）的字号和字重
   - 设置正文字号（14px）和行高（1.5）
   - 配置代码字体（等宽字体，Monaco、Menlo）

**阶段 3：自定义组件开发（Week 3-4）**

Element Plus 不直接提供但项目需要的组件：

1. **CodeViewer（代码查看器）**
   - 使用 Prism.js 或 highlight.js 进行语法高亮
   - 支持多种编程语言
   - 显示行号和代码折叠

2. **DiffViewer（代码对比查看器）**
   - 并排或统一 diff 视图
   - 高亮显示新增、删除、修改的代码行
   - 支持展开/折叠上下文

3. **CallGraphViewer（调用链路可视化）**
   - 基于 ECharts 或 G6（AntV）
   - 交互式图表（缩放、拖拽、点击高亮）
   - 节点颜色编码（循环依赖用红色标识）
   - 导出功能（PNG、SVG、Mermaid）

4. **IssueCard（问题卡片）**
   - 基于 Element Plus Card 扩展
   - 严重级别视觉编码（颜色 + 图标）
   - 展开/折叠代码片段
   - 快速操作按钮（标记已处理、忽略）

5. **ScoreIndicator（评分指示器）**
   - 环形进度条或仪表盘样式
   - 颜色分级（60 以下红色、60-80 黄色、80 以上绿色）
   - 动画效果

6. **ReviewSummary（审查摘要）**
   - 关键指标卡片（总问题数、Error/Warning/Info 数量、评分）
   - 问题分布饼图或柱状图
   - 趋势折线图（可选）

**阶段 4：组件库建设（Week 5-6）**

1. **内部组件库**
   - 整理自定义组件为独立的组件库
   - 编写组件 API 文档和使用示例
   - 制定组件开发和命名规范

2. **组件展示和测试**
   - 集成 Storybook 进行组件展示
   - 编写单元测试和视觉回归测试
   - 建立组件更新和版本管理流程

### Customization Strategy

**保留原样的部分：**

1. **基础组件**：Button、Input、Select、Checkbox、Radio、Switch 等保持 Element Plus 默认样式
2. **布局组件**：Container、Header、Aside、Main、Footer 使用默认布局系统
3. **反馈组件**：Message、Notification、MessageBox、Loading 使用默认行为和样式
4. **导航组件**：Menu、Breadcrumb、Tabs 保持默认交互逻辑

**需要主题定制的部分：**

1. **颜色系统**：调整主色调和语义色以匹配品牌和情感目标
2. **字体系统**：设置适合代码展示的字体家族和字号
3. **间距系统**：微调组件间距以优化信息密度
4. **圆角和阴影**：调整为更简洁专业的风格

**需要自定义开发的组件：**

1. **代码相关组件**：CodeViewer、DiffViewer（Element Plus 不提供）
2. **可视化组件**：CallGraphViewer、ScoreIndicator、ReviewSummary（需要专门设计）
3. **业务特定组件**：IssueCard、ReviewTaskCard、ProjectConfigForm（业务逻辑定制）

**设计 Token 定义：**

```css
/* 颜色系统 */
--primary-color: #409EFF;
--error-color: #F56C6C;
--warning-color: #E6A23C;
--success-color: #67C23A;
--info-color: #909399;

/* 字体系统 */
--font-family-base: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
--font-family-code: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
--font-size-base: 14px;
--line-height-base: 1.5;
--line-height-code: 1.6;

/* 间距系统 */
--spacing-xs: 4px;
--spacing-sm: 8px;
--spacing-md: 16px;
--spacing-lg: 24px;
--spacing-xl: 32px;
```

## 2. Core Interaction Design

### 2.1 Defining Experience

**AI Code Review 的核心体验：扫描审查报告，快速定位和理解关键问题**

这是产品的灵魂交互 - 开发者收到审查报告后，打开 Web 界面的第一件事就是快速扫描问题列表，找到最严重的问题（Error 级别），理解问题的本质和影响，并获得修复方向。

这个核心体验类似于：
- VS Code 的问题面板 - 扫描列表快速定位错误
- GitHub PR Review - 扫描代码变更和评论理解问题
- Sentry 错误列表 - 优先查看严重错误

**如果我们把这个交互做到极致：**
- 用户在 3 秒内就能知道"有没有阻塞问题"
- 用户在 10 秒内能定位并理解最关键的问题
- 用户在 30 秒内清楚所有 Error 并开始修复
- 用户全程感到掌控、自信，不会迷失

**定义成功的标准：**
用户应该能够描述这个体验为："打开报告，立刻看到 3 个 Error，点开第一个，看到 SQL 注入风险，代码和修复建议都很清楚，马上就知道该怎么改。"

### 2.2 User Mental Model

**用户当前如何解决代码审查问题：**

**1. 人工代码审查**
- 工作方式：团队成员手动 Review 代码，提出评论
- 优点：理解上下文，给出针对性建议
- 痛点：耗时、标准不一致、容易遗漏关键问题
- 用户期望：快速、全面、标准化

**2. 静态分析工具（SonarQube, ESLint）**
- 工作方式：自动扫描代码，生成问题报告
- 优点：全面、自动化、标准化
- 痛点：报告冗长、误报多、缺少修复建议、上下文不足
- 用户期望：精准识别、减少噪音、提供指导

**3. Git Diff + PR 评论**
- 工作方式：查看代码变更，在 PR 中添加评论
- 优点：与工作流集成、上下文清晰
- 痛点：缺少自动化分析、依赖人工

**用户带来的心智模型：**

1. **分级思维**：Error > Warning > Info（严重性优先）
2. **文件定位**：习惯按文件路径组织和查找问题
3. **上下文需求**：需要看到问题代码的前后几行
4. **批量处理**：希望一次看到所有问题，而不是逐个发现
5. **视觉编码**：红色 = 严重，黄色 = 警告，绿色 = 通过

**用户容易困惑的地方：**

1. **AI 判定的可信度**："这真的是问题吗？还是误报？"
2. **问题优先级**："我应该先修复哪个？全部修复吗？"
3. **修复方法不明确**："具体该怎么改代码？"
4. **阈值逻辑不清**："为什么被阻止合并？"

**设计响应：**

- 提供判定依据和解释，建立信任
- 清晰的严重性分级和自动排序
- 具体的修复建议和代码示例
- 透明的阈值配置和拦截说明

### 2.3 Success Criteria

**用户说"这就对了"的时刻：**

**时刻 1：3 秒内看到关键问题（首屏加载）**
- ✅ 评分和总体状态立即可见（75/100，⚠️ 需要注意）
- ✅ Error 数量突出显示（红色徽章："● 3 Errors"）
- ✅ 问题列表首条已经可见，无需滚动
- ✅ 视觉层次清晰，Error 优先展示

**时刻 2：10 秒内理解问题本质（点击详情）**
- ✅ 点击立即展开，无延迟（<0.5 秒）
- ✅ 问题描述清晰：原因、影响、风险
- ✅ 代码片段语法高亮，问题行明确标识
- ✅ 有足够的上下文（前后 3-5 行代码）

**时刻 3：30 秒内知道如何修复（查看建议）**
- ✅ 具体的修复建议，不是泛泛而谈
- ✅ 代码修复示例，可以直接参考
- ✅ 参考文档链接（如 OWASP 安全指南）
- ✅ 快速操作：标记已处理、忽略、跳转文件

**时刻 4：全程感到掌控和自信**
- ✅ 清楚知道总共有多少问题
- ✅ 理解每个问题的严重程度和优先级
- ✅ 有明确的修复路径和行动计划
- ✅ 进度可追踪（3/3 Errors 已处理）

**量化成功指标：**

| 指标 | 目标 | 测量方式 |
|------|------|---------|
| 首屏加载时间 | < 3 秒 | 性能监控 |
| 问题详情展开时间 | < 0.5 秒 | 性能监控 |
| 用户定位 Error 时间 | < 10 秒 | 用户测试 |
| 理解修复方向时间 | < 30 秒 | 用户测试 |
| 误点击率 | < 5% | 行为分析 |
| 任务完成率 | > 90% | 行为分析 |

### 2.4 Novel vs. Established Patterns

**采用成熟模式（降低学习成本）：**

**1. 问题列表 + 详情面板（VS Code, Sentry）**
- 用户已经熟悉这种模式
- 左侧或上方列表浏览，下方或右侧查看详情
- 键盘导航支持（上下键切换问题）
- 无需学习新交互

**2. 颜色编码（通用约定）**
- 红色 (#F56C6C) = 严重/Error
- 黄色 (#E6A23C) = 警告/Warning
- 蓝色 (#909399) = 信息/Info
- 绿色 (#67C23A) = 成功/通过
- 符合开发者工具的通用约定

**3. Tab 切换视图（Chrome DevTools, VS Code）**
- 报告总览 / 问题列表 / 调用链路图 / 配置
- Tab 导航是开发者熟悉的模式
- 清晰的视图切换，状态保持

**4. 代码语法高亮和 Diff 视图（GitHub, GitLab）**
- 使用标准的代码高亮库（Prism.js, highlight.js）
- Diff 视图遵循 Git 约定（+ 绿色添加，- 红色删除）
- 行号显示和代码折叠

**创新点（差异化体验）：**

**1. 智能问题分组和关联**
- 不仅按严重性，还按类别（安全/性能/质量）智能分组
- 识别相似问题并聚合："这个问题影响 5 个文件"
- 识别问题依赖关系："修复这个会解决另外 2 个问题"
- **学习成本**：低，基于熟悉的分组概念
- **教育方式**：首次使用时工具提示："我们已将相似问题分组"

**2. 内联修复建议（类似 VS Code 快速修复）**
- 不只是描述问题，直接给出代码修复示例
- 类似 VS Code 的"灯泡图标"快速修复
- "Before" 和 "After" 代码对比
- **学习成本**：低，借鉴 VS Code 用户熟悉的模式
- **教育方式**：明确的视觉提示（"修复建议"标题 + 代码块）

**3. 交互式调用链路可视化**
- 传统工具只列出问题，不展示依赖关系
- 交互式图表直观展示代码调用链
- 循环依赖用红色高亮，一目了然
- 点击节点查看详情，拖拽调整视图
- **学习成本**：中等，需要简单教育
- **教育方式**：首次使用显示交互指南："点击节点查看详情，滚轮缩放，拖拽移动"

**平衡策略：**
- 核心交互（问题浏览、详情查看）使用成熟模式，零学习成本
- 增值功能（调用链路、智能分组）适度创新，提供差异化价值
- 创新功能提供清晰的引导提示，首次使用有教学
- 所有创新都基于用户熟悉的隐喻（图表、分组、快速修复）

### 2.5 Experience Mechanics

**核心交互：扫描审查报告并定位问题**

**阶段 1：启动 - 进入审查报告**

**触发方式：**
- **方式 A（80%）**：收到邮件或 Git 评论通知 → 点击链接 → 直接进入报告
- **方式 B（20%）**：打开 Web 界面 → 点击"审查历史" → 选择最新报告

**首屏内容（3 秒内加载）：**
- 评分卡片：75/100，⚠️ 需要注意
- 问题统计：● 3 Errors ● 8 Warnings ● 4 Info
- 筛选工具栏：全部(15) | Error(3) | Warning(8) | Info(4)
- 问题列表：前 3 个 Error 已可见

**阶段 2：交互 - 定位和理解问题**

**交互 A：展开问题详情**
- 点击问题卡片 → 0.5 秒内展开
- 显示：问题描述 + 代码片段（语法高亮）+ 修复建议 + 快速操作

**交互 B：筛选问题**
- 点击 "Error(3)" → 立即只显示 Error 级别
- 标签高亮，显示"已筛选 3 个 Error"

**交互 C：搜索问题**
- 输入关键词 → 实时搜索
- 高亮匹配内容，显示匹配数量

**交互 D：切换视图**
- 点击"调用链路" Tab → 切换到可视化图表
- 首次使用显示交互指南

**阶段 3：反馈 - 确认理解和进度**

**视觉反馈：**
- 问题行用淡红色背景标识
- 鼠标悬停显示更多解释（Tooltip）
- 代码语法高亮保持可读性

**进度追踪：**
- 标记已处理 → 卡片变灰，显示 ✓
- 顶部摘要实时更新："2/3 Errors 已处理"
- 批量操作：选择多个问题批量标记

**导航反馈：**
- 点击"查看完整文件" → 新 Tab 打开，自动滚动到问题行
- 面包屑导航：项目 > 报告 > 问题 #001

**阶段 4：完成 - 明确下一步**

**完成状态 A：所有 Error 已处理**
- 显示成功卡片："✅ 所有严重问题已解决！评分从 75 提升至 92"
- 行动建议：[提交代码重新审查]

**完成状态 B：部分完成**
- 显示进度："✅ 3/3 Errors 已处理，⚠️ 5/8 Warnings 待处理"
- 行动建议：[继续处理 Warning] [暂时保存]

**智能推荐下一步：**
- 全部修复 → "提交代码重新审查"
- Error 已处理 → "继续处理 Warning"
- 发现误报 → "调整审查规则"
